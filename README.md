# BSU_OS_collocvium_Vlasenko_10_3
collocvium number 3 in operational systems 
# 1. Классические поведенческие шаблоны проектирования
Поведенческие шаблоны определяют способы взаимодействия объектов и классов, обеспечивая гибкость и расширяемость кода. Рассмотрим три шаблона: Состояние, Посредник, Наблюдатель — через призму инкапсуляции, разделения ответственности и ортогональных стратегий, а также влияние многопоточности.

## 1.1. Шаблон «Состояние» (State)
Проблема:

Объект должен менять поведение в зависимости от внутреннего состояния.

Прямые проверки состояния (if-else/switch) усложняют код и нарушают принцип открытости/закрытости (OCP).

## Решение:

Инкапсуляция состояний в отдельные классы, реализующие общий интерфейс.

Контекст делегирует работу текущему состоянию, избегая условных операторов.

## Примеры:

Документ (Черновик/На проверке/Опубликован)

В зависимости от состояния, методы publish() или edit() ведут себя по-разному.

Новые состояния добавляются без изменения существующего кода.

Торговый автомат

Состояния: NoCoin, HasCoin, Sold, SoldOut.

Метод insertCoin() в состоянии SoldOut игнорируется.

Игровой персонаж (Бег/Прыжок/Атака)

Переключение анимации и физики через состояния.

## Многопоточность:

Если состояние изменяется из разных потоков, требуется синхронизация (например, std::mutex в C++).

## 1.2. Шаблон «Посредник» (Mediator)
Проблема:

Множество объектов взаимодействуют друг с другом напрямую, создавая сильную связанность.

Изменение одного объекта требует модификации других.

## Решение:

Разделение взаимодействий через центральный объект-посредник.

Объекты общаются только с посредником, не зная друг о друге (ортогональность).

## Примеры:

Чат-комната

Пользователи (User) отправляют сообщения не друг другу, а через ChatRoom.

Посредник может добавлять логирование или фильтрацию.

Управление авиарейсами

Самолеты (Aircraft) не координируются напрямую, а через AirTrafficControl.

GUI-приложение (Qt)

QDialog может выступать посредником между кнопками (QPushButton) и полями ввода (QLineEdit).

## Многопоточность:

Посредник может стать узким местом. Решения:

Асинхронная обработка (например, очередь сообщений).

Thread-safe реализация (блокировки, атомарные операции).

## 1.3. Шаблон «Наблюдатель» (Observer)
Проблема:

Объект (Subject) должен уведомлять другие объекты (Observers) об изменениях, но без жесткой зависимости.

## Решение:

Подписка/уведомление через интерфейс.

Subject инкапсулирует список наблюдателей и вызывает их методы при изменениях.

## Примеры:

Погодная станция (Qt Example)

В Qt есть QObserver и QObservable, но чаще используют сигналы/слоты (QObject::connect).

cpp
// Qt пример: кнопка уведомляет обработчик
QPushButton *button = new QPushButton("Click me");
QObject::connect(button, &QPushButton::clicked, []() { qDebug() << "Button clicked!"; });
Фондовый рынок

Акция (Stock) уведомляет трейдеров (Trader) при изменении цены.

Редактор текста

Изменение документа (Document) обновляет представления (TextView, TreeView).

## Многопоточность:

Если наблюдатели обновляются из разных потоков:

## Проблема: Гонка данных при изменении списка наблюдателей.

## Решение:

Иммьютабельные данные уведомлений.

Очередь событий (например, QEventLoop в Qt).

# 2. Дизайн ПО и влияние многопоточности
## 2.1. Что такое дизайн ПО?
Дизайн ПО — это процесс создания архитектуры и структуры программы, включая:

Выбор паттернов (например, MVC, Observer).

Разделение ответственности (SOLID-принципы).

Ортогональность — минимизацию влияния изменений в одной части системы на другие.

## 2.2. Влияние многопоточности на дизайн
Усложнение управления состоянием

Шаблоны вроде State требуют синхронизации (например, std::lock_guard).

Проблемы с наблюдателями

Асинхронные уведомления (например, через QMetaObject::invokeMethod в Qt).

Посредник как bottleneck

## Решение: thread-safe очереди (BlockingQueue в Java, QMutex в Qt).

Иммутабельность

Данные, передаваемые между потоками, должны быть неизменяемыми (как в React/Redux).

## Вывод:
Многопоточность требует:

Избегания общего состояния (shared state).

Использования атомарных операций и immutable-данных.

Паттернов вроде Producer-Consumer (очереди задач).

## Пример:

cpp
// Потокобезопасный Observer в C++
class ThreadSafeSubject {
    std::vector<std::shared_ptr<Observer>> observers;
    std::mutex mtx;
public:
    void addObserver(std::shared_ptr<Observer> obs) {
        std::lock_guard<std::mutex> lock(mtx);
        observers.push_back(obs);
    }
    void notifyAll() {
        std::lock_guard<std::mutex> lock(mtx);
        for (auto& obs : observers) obs->update();
    }
};
Таким образом, дизайн системы должен учитывать многопоточность с самого начала, иначе рефакторинг будет сложным и дорогим.


